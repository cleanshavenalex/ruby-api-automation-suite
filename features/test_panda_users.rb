require './init'

class TestPandaUsers < APITest

  USER_KEYS = ['ascp_terms_accepted_at','avatar_url','autogenerated_email','communication_options','cookie_id','ip','id',
               'created_at','display_name','email','email_token','first_name','hide_third_party_photo','birth_date',
               'is_deleted','is_superuser','last_access_date','last_login_date','last_name','location','login_attempt',
               'marketing_optout','news_letter_optin','password_last_updated','password_reset','security_answer','sex',
               'security_question','sharing_optout','site','source','street_address','suppressed','suppressed_by',
               'suppressed_reason','terms','type','updated_at','user_name','verified','yp_user_name','zip_code','phone']
  
  def setup
    assign_http(Config['panda']['host'])
    @user = TurtleUser.new
  end

  ##
  # AS-6178 | API Test for User Endpoints
  # - GET '/usr/multi'
  # Steps:
  # 1. Verify response for request with one user
  # 2. Verify response for request with multiple users
  # 3. Verify response for request with invalid / non-existing user along with valid users
  # 4. Verify response for request with missing users / empty array
  def test_users_multi
    # Setup
    @user1 = setup_user
    @user2 = setup_user
    @user3 = setup_user

    # Step 1
    users = [@user1.id]

    params = {
        'user_ids' => users
    }

    get '/usr/multi', params
    assert_response(@response, :success)
    assert_kind_of(Hash, @parsed_response)
    assert_equal(users[0], @parsed_response[users[0].to_s]['id'], @parsed_response)

    users.each do |user|
      USER_KEYS.each do |field|
        refute_nil(@parsed_response[user.to_s][field], @parsed_response) if @parsed_response[user.to_s][field]
      end
    end

    # Step 2
    users = [@user1.id, @user2.id, @user3.id]

    params = {
        'user_ids' => users
    }

    get '/usr/multi', params
    assert_response(@response, :success)
    assert_equal(users[0], @parsed_response[users[0].to_s]['id'], @parsed_response)
    assert_equal(users[1], @parsed_response[users[1].to_s]['id'], @parsed_response)
    assert_equal(users[2], @parsed_response[users[2].to_s]['id'], @parsed_response)

    users.each do |user|
      USER_KEYS.each do |field|
        refute_nil(@parsed_response[user.to_s][field], @parsed_response) if @parsed_response[user.to_s][field]
      end
    end

    # Step 3
    invalid_user_id = @user3.id + 100000
    mixed_users = [@user1.id, @user2.id, invalid_user_id, @user3.id]
    valid_users = [@user1.id, @user2.id, @user3.id]

    params = {
        'user_ids' => mixed_users
    }

    get '/usr/multi', params
    assert_response(@response, :success)
    assert_equal(mixed_users[0], @parsed_response[mixed_users[0].to_s]['id'], @parsed_response)
    assert_equal(mixed_users[1], @parsed_response[mixed_users[1].to_s]['id'], @parsed_response)
    assert_equal(mixed_users[3], @parsed_response[mixed_users[3].to_s]['id'], @parsed_response)

    valid_users.each do |user|
      USER_KEYS.each do |field|
        refute_nil(@parsed_response[user.to_s][field], @parsed_response) if @parsed_response[user.to_s][field]
      end
    end

    # Step 4
    users = []

    params = {
        'user_ids' => users
    }

    get '/usr/multi', params
    assert_response(@response, :client_error)
    assert_equal('InvalidParamsError', @parsed_response['error'], @parsed_response)
    assert_equal("parameter(s) \"user_ids\" must be of type `Array'", @parsed_response['message'], @parsed_response)
  end

  ##
  # AS-5755 | Test users profile endpoint
  # - GET '/usr/profile'
  # Steps:
  # 1. Verify success response for user_id
  # 2. Verify success response for oauth_token
  # 3. Verify success response for user_id & oauth_token
  # 4. Verify success response for user who uploaded image and review
  # 5. Verify client_error response for invalid user & oauth_token
  # 6. Verify client_error response for missing / blank user_id & oauth_token
  def test_users_profile
    # Setup
    int_xxids = get_rateable_int_xxids_from_search('bicycle repair', 'new york city, ny')
    int_xxid = int_xxids.sample

    @user = setup_user

    ## /usr/profile returns fields using CamelCase
    default_fields = []
    USER_KEYS.each do |field|
      default_fields << field.camelize
    end

    private_user_keys = ['Email', 'FirstName', 'Id', 'LastName']

    # Step 1
    params = {
        'user_id' => @user.id
    }

    get '/usr/profile', params
    assert_response(@response, :success)
    refute(@parsed_response['CurrentUser'], 'Expected CurrentUser to be false but was true')
    refute_has_keys(@parsed_response['User'], private_user_keys)

    default_fields.each do |field|
      refute_nil(@parsed_response['User'][field], @parsed_response) if @parsed_response['User'][field]
    end

    # Step 2
    params = {
        'oauth_token' => @user.oauth_token
    }

    get '/usr/profile', params
    assert_response(@response, :success)
    assert(@parsed_response['CurrentUser'], 'Expected CurrentUser to be true but was false')
    assert_has_keys(@parsed_response['User'], private_user_keys)

    default_fields.each do |field|
      refute_nil(@parsed_response['User'][field], @parsed_response) if @parsed_response['User'][field]
    end

    # Step 3
    params = {
        'user_id' => @user.id,
        'oauth_token' => @user.oauth_token
    }

    get '/usr/profile', params
    assert_response(@response, :success)
    assert(@parsed_response['CurrentUser'], 'Expected CurrentUser to be true but was false')
    assert_has_keys(@parsed_response['User'], private_user_keys)

    default_fields.each do |field|
      refute_nil(@parsed_response['User'][field], @parsed_response) if @parsed_response['User'][field]
    end

    # Step 4
    assert_equal(0, @parsed_response['Reviews']['Count'], @parsed_response)
    assert_equal(0, @parsed_response['Images']['Count'], @parsed_response)

    upload_and_link_image('int_xxid', int_xxid, @user.oauth_token)
    review_business(int_xxid, @user.oauth_token)

    get '/usr/profile', params
    assert_response(@response, :success)
    assert_equal(1, @parsed_response['Reviews']['Count'], @parsed_response)
    assert_equal(1, @parsed_response['Images']['Count'], @parsed_response)

    # Step 5
    params = {
        'oauth_token' => @user.oauth_token + 'ABC123'
    }

    get '/usr/profile', params
    assert_response(@response, :client_error)
    assert_equal(@parsed_response['error'], 'UserNotFoundError', @parsed_response)

    params = {
        'oauth_token' => @user.id + 999999
    }

    get '/usr/profile', params
    assert_response(@response, :client_error)
    assert_equal(@parsed_response['error'], 'UserNotFoundError', @parsed_response)

    # Step 6
    params = {
        'user_id' => '',
        'oauth_token' => ''
    }

    get '/usr/profile', params
    assert_response(@response, :client_error)
    assert_equal(@parsed_response['error'], 'InvalidParamsError', @parsed_response)
    assert_equal(@parsed_response['message'], "one of [\"oauth_token\", \"access_token\", \"user_id\"] are required", @parsed_response)
  end

  ##
  # AS-6178 | API Test for User Endpoints
  # - GET '/usr/profile/multi'
  # Steps:
  # 1. Verify success response for single user_id
  # 2. Verify success response for single user_id + oauth_token
  # 3. Verify success response for single user_id who uploaded image and review
  # 4. Verify success response for multiple user_id's
  # 5. Verify success response for multiple user_id's + oauth_token
  # 6. Verify success response for multiple user_id's + non-associated oauth_token
  # 7. Verify success response for mixed valid & invalid user_id's
  # 8. Verify success response for mixed valid & invalid user_id's + oauth_token
  def test_users_profile_multi
    # Setup
    int_xxids = get_rateable_int_xxids_from_search("bicycle repair", "new york city, ny")
    int_xxid = int_xxids.sample

    @user1 = setup_user
    @user2 = setup_user
    @user3 = setup_user

    ## /usr/profile returns fields using CamelCase
    default_fields = []
    USER_KEYS.each do |field|
      default_fields << field.camelize
    end

    private_user_keys = ['Email', 'FirstName', 'Id', 'LastName']

    # Step 1
    users = [@user1.id]

    params = {
        'user_ids' => users
    }

    get '/usr/profile/multi', params
    assert_response(@response, :success)

    users.each do |user_id|
      refute_has_keys(@parsed_response[user_id.to_s]['User'], private_user_keys)

      default_fields.each do |field|
        refute_nil(@parsed_response[user_id.to_s]['User'][field], @parsed_response) if @parsed_response[user_id.to_s]['User'][field]
      end
    end

    # Step 2
    users = [@user1.id]

    params = {
        'user_ids' => users,
        'oauth_token' => @user1.oauth_token
    }

    get '/usr/profile/multi', params
    assert_response(@response, :success)

    users.each do |user_id|
      assert_has_keys(@parsed_response[user_id.to_s]['User'], private_user_keys)

      default_fields.each do |field|
        refute_nil(@parsed_response[user_id.to_s]['User'][field], @parsed_response) if @parsed_response[user_id.to_s]['User'][field]
      end
    end

    # Step 3
    assert_equal(0, @parsed_response[@user1.id.to_s]['Reviews']['Count'], @parsed_response)
    assert_equal(0, @parsed_response[@user1.id.to_s]['Images']['Count'], @parsed_response)

    upload_and_link_image('int_xxid', int_xxid, @user1.oauth_token)
    review_business(int_xxid, @user1.oauth_token)

    get '/usr/profile/multi', params
    assert_response(@response, :success)
    assert_equal(1, @parsed_response[@user1.id.to_s]['Reviews']['Count'], @parsed_response)
    assert_equal(1, @parsed_response[@user1.id.to_s]['Images']['Count'], @parsed_response)

    # Step 4
    users = [@user1.id, @user2.id, @user3.id]

    params = {
        'user_ids' => users
    }

    get '/usr/profile/multi', params
    assert_response(@response, :success)

    users.each do |user_id|
      refute_has_keys(@parsed_response[user_id.to_s]['User'], private_user_keys)

      default_fields.each do |field|
        refute_nil(@parsed_response[user_id.to_s]['User'][field], @parsed_response) if @parsed_response[user_id.to_s]['User'][field]
      end
    end

    # Step 5
    users = [@user1.id, @user2.id, @user3.id]

    params = {
        'user_ids' => users,
        'oauth_token' => @user2.oauth_token
    }

    get '/usr/profile/multi', params
    assert_response(@response, :success)

    users.each do |user_id|
      if user_id == @user1.id || user_id == @user3.id
        refute_has_keys(@parsed_response[user_id.to_s]['User'], private_user_keys)
      else
        assert_has_keys(@parsed_response[user_id.to_s]['User'], private_user_keys)
      end

      default_fields.each do |field|
        refute_nil(@parsed_response[user_id.to_s]['User'][field], @parsed_response) if @parsed_response[user_id.to_s]['User'][field]
      end
    end

    # Step 6
    users = [@user1.id, @user2.id]

    params = {
        'user_ids' => users,
        'oauth_token' => @user3.oauth_token
    }

    get '/usr/profile/multi', params
    assert_response(@response, :success)

    users.each do |user_id|
      refute_has_keys(@parsed_response[user_id.to_s]['User'], private_user_keys)

      default_fields.each do |field|
        refute_nil(@parsed_response[user_id.to_s]['User'][field], @parsed_response) if @parsed_response[user_id.to_s]['User'][field]
      end
    end

    # Step 7
    invalid_user_id = @user1.id + 9999999
    mixed_users = [@user1.id, invalid_user_id, @user3.id]
    valid_users = [@user1.id, @user3.id]

    params = {
        'user_ids' => mixed_users
    }

    get '/usr/profile/multi', params
    assert_response(@response, :success)

    valid_users.each do |user_id|
      refute_has_keys(@parsed_response[user_id.to_s]['User'], private_user_keys)

      default_fields.each do |field|
        refute_nil(@parsed_response[user_id.to_s]['User'][field], @parsed_response) if @parsed_response[user_id.to_s]['User'][field]
      end
    end
  end

  ##
  # AS-6178 | API Test for User Endpoints
  # - GET '/usr/images'
  # Steps:
  # 1. Verify success response for user_id
  # 2. Verify success response for user_id + oauth_token in params (should ignore oauth_token)
  # 3. Verify client_error response for oauth_token
  def test_users_images
    # Setup
    @user = setup_user

    int_xxids = get_rateable_int_xxids_from_search('restaurants', 'new york city, ny')

    3.times do
      upload_and_link_image('int_xxid', int_xxids.sample, @user.oauth_token)
    end

    params = {
        'user_id' => @user.id
    }

    get '/usr/profile', params
    assert_response(@response, :success)
    assert(@parsed_response['Images']['Count'] >= 3, @parsed_response)

    # Step 1
    params = {
        'user_id' => @user.id
    }

    get '/usr/images', params
    assert_response(@response, :success)

    @parsed_response['images'].each do |response|
      assert_equal(@user.id, response['user_id'], 'Expected user_id does not match!')
      assert(response['full_image_path'], 'The full_image_path is missing or nil!')
      assert_equal('image', response['b_image_media_type'], "Expected b_image_media_type to be image: #{response['b_image_media_type']}")
    end

    # Step 2
    params = {
        'user_id' => @user.id,
        'oauth_token' => @user.oauth_token
    }

    get '/usr/images', params
    assert_response(@response, :success)

    @parsed_response['images'].each do |response|
      assert_equal(@user.id, response['user_id'], 'Expected user_id does not match!')
      assert(response['full_image_path'], 'The full_image_path is missing or nil!')
      assert_equal('image', response['b_image_media_type'], "Expected b_image_media_type to be image: #{response['b_image_media_type']}")
    end

    # Step 3
    params = {
        'oauth_token' => @user.oauth_token
    }

    get '/usr/images', params
    assert_response(@response, :client_error)
    assert_equal(@parsed_response['error'], 'InvalidParamsError', @parsed_response)
    assert_equal(@parsed_response['message'], "parameter(s) \"user_id\" must not be blank", @parsed_response)
  end

  ##
  # API test to check Dragon matches the Panda user details
  #
  # Steps:
  # Setup
  # 1. Lookup the new User from Panda
  # 2. Verify the new User from Panda matches the new User added to Dragon
  # 3. New user updates User info from Panda
  # 4. Verify the updated User from Panda matches the User updated in Dragon
  def test_newly_created_and_updated_user_displays_in_dragon
    # Setup
    @user = setup_user

    # Step 1
    lookup_user_by_email(@user.email)
    assert_equal(@user.email, @parsed_response['email'], @parsed_response)

    panda_response = @parsed_response

    # Step 2
    get_dragon_user(@user.id)
    assert_response(@response, :success)

    dragon_response = @parsed_response
    assert_dragon_user_params(panda_response, dragon_response)

    # Step 3
    params = {
        'user' => {
            'first_name' => 'Bill',
            'last_name' => 'Maher'
        }
    }

    put "/usr/#{@user.cookie_id}", params
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal('Bill', @parsed_response['first_name'], @parsed_response)
    assert_equal('Maher', @parsed_response['last_name'], @parsed_response)
    assert_equal('Bill M.', @parsed_response['display_name'], @parsed_response)
  end

  #--------------------------------------#
  # User endpoints ported from Cheetah #
  #--------------------------------------#

  ##
  # AS-5486 | Test Migrated Cheetah to Panda User Endpoints
  # - GET '/usr'
  # Steps:
  # 1. A User signs up and logs in
  # 2. Verify response & email for request new user
  # 3. Verify default fields returned are not nil
  def test_defaults_get_users
    # Step 1
    @user = setup_user

    # Step 2
    params = { 'email' => @user.email }

    get '/usr', params
    assert_response(@response, :success)
    assert_equal(@user.email, @parsed_response.first['email'], @parsed_response)

    # Step 3
    USER_KEYS.each do |field|
      refute_nil(@parsed_response.first[field], @parsed_response) if @parsed_response.first[field]
    end
  end

  ##
  # AS-5486 | Test Migrated Cheetah to Panda User Endpoints
  # - GET '/usr/lookup'
  # - GET '/usr/:email_token/em_token' (part of lookup)
  # - GET '/v1/usr/lookup' (rewrite rules, backwards compatibility)
  #
  # Steps:
  # 1. A User signs up and logs in
  # 2. Verify user details for response by email
  # 3. Verify default fields returned are not nil
  # 4. Verify user details for response by email_token
  # 5. Verify default fields returned are not nil
  # 6. Verify user details for response by cookie_id
  # 7. Verify default fields returned are not nil
  # 8. Verify user details for response by id
  # 9. Verify default fields returned are not nil
  # 10. Verify user details for response by email using /v1 path
  # 11. Verify default fields returned are not nil
  def test_defaults_get_users_lookup
    # Step 1
    @user = setup_user

    # Step 2
    params = { 'email' => @user.email }

    get '/usr/lookup', params
    assert_response(@response, :success)
    assert_equal(@user.email, @parsed_response['email'], @parsed_response)

    # Step 3
    USER_KEYS.each do |field|
      refute_nil(@parsed_response[field], @parsed_response) if @parsed_response[field]
    end

    # Step 4
    get "/usr/#{@user.email_token}/em_token", {}
    assert_response(@response, :success)
    assert_equal(@user.email_token, @parsed_response['email_token'], @parsed_response)

    # Step 5
    USER_KEYS.each do |field|
      refute_nil(@parsed_response[field], @parsed_response) if @parsed_response[field]
    end

    # Step 6
    params = { 'cookie_id' => @user.cookie_id }

    get '/usr/lookup', params
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)

    # Step 7
    USER_KEYS.each do |field|
      refute_nil(@parsed_response[field], @parsed_response) if @parsed_response[field]
    end

    # Step 8
    params = { 'id' => @user.id }

    get '/usr/lookup', params
    assert_response(@response, :success)
    assert_equal(@user.id, @parsed_response['id'], @parsed_response)

    # Step 9
    USER_KEYS.each do |field|
      refute_nil(@parsed_response[field], @parsed_response) if @parsed_response[field]
    end

    # Step 10
    params = { 'email' => @user.email }

    get '/v1/usr/lookup', params
    assert_response(@response, :success)
    assert_equal(@user.email, @parsed_response['email'], @parsed_response)

    # Step 11
    USER_KEYS.each do |field|
      refute_nil(@parsed_response[field], @parsed_response) if @parsed_response[field]
    end
  end

  ##
  # AS-5486 | Test Migrated Cheetah to Panda User Endpoints
  # - GET '/usr/:cookie_id'
  # Steps:
  # 1. A User signs up and logs in
  # 2. Verify User details for response
  # 3. Verify default fields returned are not nil
  def test_defaults_get_users_by_cookie_id
    # Step 1
    @user = setup_user

    # Step 2
    get "/usr/#{@user.cookie_id}", {}
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)

    # Step 3
    USER_KEYS.each do |field|
      refute_nil(@parsed_response[field], @parsed_response) if @parsed_response[field]
    end
  end

  ##
  # AS-5486 | Test Migrated Cheetah to Panda User Endpoints
  # - PUT '/usr/:cookie_id'
  # Steps:
  # 1. A User signs up and logs in
  # 2. Confirm First, Last, and Display Name in initial response
  # 3. Verify User update to First and Last Name, and auto update to Display Name
  # 4. Verify User update to User Name, and auto update to Display Name, but not First and Last Name
  # 5. Verify User update to email and other options
  # 6. Verify User update to address options
  def test_updates_by_cookie_id
    # Step 1
    params = {
        'first_name' => 'Jack',
        'last_name' => 'Johnson'
    }

    @user = setup_user params

    get_user_info(@user.oauth_token)
    assert_equal(@user.first_name, @parsed_response['first_name'])
    assert_equal(@user.last_name, @parsed_response['last_name'])
    assert_equal(1, @parsed_response['terms'])

    # Step 2
    get "/usr/#{@user.cookie_id}", {}
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal(@user.first_name, @parsed_response['first_name'], @parsed_response)
    assert_equal(@user.last_name, @parsed_response['last_name'], @parsed_response)
    assert_equal(@user.display_name, (@user.first_name + ' ' + @user.last_name[0,1] + '.'), @parsed_response)

    # Step 3
    params = {
      'user' => {
          'first_name' => 'Bill',
          'last_name' => 'Maher'
      }
    }

    put "/usr/#{@user.cookie_id}", params
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal('Bill', @parsed_response['first_name'], @parsed_response)
    assert_equal('Maher', @parsed_response['last_name'], @parsed_response)
    assert_equal('Bill M.', @parsed_response['display_name'], @parsed_response)

    # Step 4
    params = {
        'user' => {
            'user_name' => 'THE MAN'
        }
    }

    put "/usr/#{@user.cookie_id}", params
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal('Bill', @parsed_response['first_name'], @parsed_response)
    assert_equal('Maher', @parsed_response['last_name'], @parsed_response)
    assert_equal('the man', @parsed_response['user_name'], @parsed_response)
    assert_equal('Bill M.', @parsed_response['display_name'], @parsed_response)

    # Step 5
    get "/usr/#{@user.cookie_id}", {}
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal(1, @parsed_response['terms'], @parsed_response)

    params = {
        'user' => {
            'email' => "updated_#{@user.email}",
            'terms' => '0'
        }
    }

    put "/usr/#{@user.cookie_id}", params
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal(params['user']['email'], @parsed_response['email'], @parsed_response)
    assert_equal(0, @parsed_response['terms'], @parsed_response)

    # Step 6
    get "/usr/#{@user.cookie_id}", {}
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_nil(@parsed_response['street_address'], @parsed_response)
    assert_nil(@parsed_response['city'], @parsed_response)
    assert_nil(@parsed_response['state'], @parsed_response)

    params = {
        'user' => {
            'street_address' => '611 N Brand Blvd.',
            'city' => 'Glendale',
            'state' => 'CA'
        }
    }

    put "/usr/#{@user.cookie_id}", params
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal('611 N Brand Blvd.', @parsed_response['street_address'], @parsed_response)
    assert_equal('Glendale, CA', @parsed_response['location'], @parsed_response)
  end

  ##
  # AS-6385 | Support for new unified_user columns
  # - PUT '/usr/:cookie_id'
  # more info: http://en.wikipedia.org/wiki/ISO/IEC_5218
  #
  # Steps:
  # 1. A User signs up and logs in
  # 2. Verify successful response to user update for sex (0, 1, 2, 9)
  # 3. Verify successful response to user update for birth_date (format: YYYY-MM-DD)
  # 4. Verify successful response to user update for phone_number (10-digit)
  # 5. Verify client error response to user update for phone_number (non-10-digit)
  def test_updates_by_cookie_id_for_new_columns
    # Step 1
    @user = setup_user
    errors = []

    # Step 2
    params = {
        'user' => {
            'sex' => nil
        }
    }

    [0,1,2,9].each do |n|
      params['user']['sex'] = n

      put "/usr/#{@user.cookie_id}", params
      if @response.code =~ /^2\d{2}$/
        assert_response(@response, :success)
        assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
        assert_equal(n, @parsed_response['sex'], @parsed_response)
      else
        errors << @parsed_response
      end
    end

    # Step 3
    params = {
        'user' => {
            'birth_date' => nil
        }
    }

    ['2000-02-29','1111-11-11','9999-09-09'].each do |date|
      params['user']['birth_date'] = date

      put "/usr/#{@user.cookie_id}", params
      if @response.code =~ /^2\d{2}$/
        assert_response(@response, :success)
        assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
        assert_equal(date, @parsed_response['birth_date'], @parsed_response)
      else
        errors << @parsed_response
      end

      #sanity check for Turtle response
      @user.verify_oauth_token(@user.oauth_token)
      if @response.code =~ /^2\d{2}$/
        assert_response(@response, :success)
        assert_equal(date, @parsed_response['birth_date'], @parsed_response)
      else
        errors << @parsed_response
      end
    end

    # Step 4
    params = {
        'user' => {
            'phone_number' => nil
        }
    }

    ['0123456789', '8185551212'].each do |pn|
      params['user']['phone_number'] = pn

      put "/usr/#{@user.cookie_id}", params
      if @response.code =~ /^2\d{2}$/
        assert_response(@response, :success)
        assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
        assert_equal(pn, @parsed_response['phone_number'], @parsed_response)
      else
        errors << @parsed_response
      end
    end

    # Step 5
    ['abc', '123', '123abc4567'].each do |pn|
      params['user']['phone_number'] = pn

      put "/usr/#{@user.cookie_id}", params
      if @response.code =~ /^4\d{2}$/
        assert_response(@response, :client_error)
        assert_equal('Phone number must be 10 numerical digits.', @parsed_response['phone_number'].first)
      else
        errors << "Expected client error for non-10-digit formatting: #{@parsed_response['phone_number']}"
      end
    end

    assert_empty(errors)
  end

  ##
  # AS-6385 | Support for new unified_user columns
  # - POST '/usr/update_by_id/:id'
  # more info: http://en.wikipedia.org/wiki/ISO/IEC_5218
  #
  # Steps:
  # 1. A User signs up and logs in
  # 2. Verify successful response to user update for sex (0, 1, 2, 9)
  # 3. Verify successful response to user update for birth_date (format: YYYY-MM-DD)
  # 4. Verify successful response to user update for phone_number (10-digit)
  # 5. Verify client error response to user update for phone_number (non-10-digit)
  def test_updates_by_user_id_for_new_columns
    # Step 1
    @user = setup_user
    errors = []

    # Step 2
    params = {
        'oauth_token' => @user.oauth_token,
        'user' => {
            'sex' => nil
        }
    }

    [0,1,2,9].each do |n|
      params['user']['sex'] = n

      post "/usr/update_by_id/#{@user.id}", params
      if @response.code =~ /^2\d{2}$/
        assert_response(@response, :success)
        assert_equal(@user.id, @parsed_response['id'], @parsed_response)
        assert_equal(n, @parsed_response['sex'], @parsed_response)
      else
        errors << @parsed_response
      end
    end

    # Step 3
    params = {
        'oauth_token' => @user.oauth_token,
        'user' => {
            'birth_date' => nil
        }
    }

    ['2000-02-29','1111-11-11','9999-09-09'].each do |date|
      params['user']['birth_date'] = date

      post "/usr/update_by_id/#{@user.id}", params
      if @response.code =~ /^2\d{2}$/
        assert_response(@response, :success)
        assert_equal(@user.id, @parsed_response['id'], @parsed_response)
        assert_equal(date, @parsed_response['birth_date'], @parsed_response)
      else
        errors << @parsed_response
      end

      #sanity check for Turtle response
      @user.verify_oauth_token(@user.oauth_token)
      if @response.code =~ /^2\d{2}$/
        assert_response(@response, :success)
        assert_equal(date, @parsed_response['birth_date'], @parsed_response)
      else
        errors << @parsed_response
      end
    end

    # Step 4
    params = {
        'oauth_token' => @user.oauth_token,
        'user' => {
            'phone_number' => nil
        }
    }

    ['0123456789', '8185551212'].each do |pn|
      params['user']['phone_number'] = pn

      post "/usr/update_by_id/#{@user.id}", params
      if @response.code =~ /^2\d{2}$/
        assert_response(@response, :success)
        assert_equal(@user.id, @parsed_response['id'], @parsed_response)
        assert_equal(pn, @parsed_response['phone_number'], @parsed_response)
      else
        errors << @parsed_response
      end
    end

    # Step 5
    ['abc', '123', '123abc4567'].each do |pn|
      params['user']['phone_number'] = pn

      post "/usr/update_by_id/#{@user.id}", params
      if @response.code =~ /^4\d{2}$/
        assert_response(@response, :client_error)
        assert_equal('Phone number must be 10 numerical digits.', @parsed_response['phone_number'].first)
      else
        errors << "Expected client error for non-10-digit formatting: #{@parsed_response['phone_number']}"
      end
    end

    assert_empty(errors)
  end

  ##
  # AS-5486 | Test Migrated Cheetah to Panda User Endpoints
  # - POST '/usr/update_by_id/:id'
  # Steps:
  # 1. A User signs up and logs in
  # 2. Confirm First, Last, and Display Name in initial response
  # 3. Verify User update to First and Last Name, and auto update to Display Name
  # 4. Verify User update to User Name, and auto update to Display Name, but not First and Last Name
  # 5. Verify User update to email and email and other options
  # 6. Verify User update to address options
  def test_updates_by_id
    # Step 1
    params = {
        'first_name' => 'Jack',
        'last_name' => 'Johnson'
    }

    @user = setup_user params

    get_user_info(@user.oauth_token)
    assert_equal(@user.first_name, @parsed_response['first_name'])
    assert_equal(@user.last_name, @parsed_response['last_name'])
    assert_equal(1, @parsed_response['terms'])

    # Step 2
    get "/usr/#{@user.cookie_id}", {}
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal(@user.first_name, @parsed_response['first_name'], @parsed_response)
    assert_equal(@user.last_name, @parsed_response['last_name'], @parsed_response)
    assert_equal(@user.display_name, (@user.first_name + ' ' + @user.last_name[0,1] + '.'), @parsed_response)

    # Step 3
    params = {
        'oauth_token' => @user.oauth_token,
        'user' => {
            'first_name' => 'Bill',
            'last_name' => 'Maher'
        }
    }

    post "/usr/update_by_id/#{@user.id}", params
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal('Bill', @parsed_response['first_name'], @parsed_response)
    assert_equal('Maher', @parsed_response['last_name'], @parsed_response)
    assert_equal('Bill M.', @parsed_response['display_name'], @parsed_response)

    # Step 4
    params = {
        'oauth_token' => @user.oauth_token,
        'user' => {
            'user_name' => 'THE MAN'
        }
    }

    post "/usr/update_by_id/#{@user.id}", params
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal('Bill', @parsed_response['first_name'], @parsed_response)
    assert_equal('Maher', @parsed_response['last_name'], @parsed_response)
    assert_equal('the man', @parsed_response['user_name'], @parsed_response)
    assert_equal('Bill M.', @parsed_response['display_name'], @parsed_response)

    # Step 5
    get "/usr/#{@user.cookie_id}", {}
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal(1, @parsed_response['terms'], @parsed_response)

    params = {
        'oauth_token' => @user.oauth_token,
        'user' => {
            'email' => "updated_#{@user.email}",
            'terms' => '0'
        }
    }

    post "/usr/update_by_id/#{@user.id}", params
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal(params['user']['email'], @parsed_response['email'], @parsed_response)
    assert_equal(0, @parsed_response['terms'], @parsed_response)

    # Step 6
    get "/usr/#{@user.cookie_id}", {}
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_nil(@parsed_response['street_address'], @parsed_response)
    assert_nil(@parsed_response['city'], @parsed_response)
    assert_nil(@parsed_response['state'], @parsed_response)

    params = {
        'oauth_token' => @user.oauth_token,
        'user' => {
            'street_address' => '611 N Brand Blvd.',
            'city' => 'Glendale',
            'state' => 'CA'
        }
    }

    post "/usr/update_by_id/#{@user.id}", params
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal('611 N Brand Blvd.', @parsed_response['street_address'], @parsed_response)
    assert_equal('Glendale, CA', @parsed_response['location'], @parsed_response)
  end

  ##
  # AS-5486 | Test Migrated Cheetah to Panda User Endpoints
  # - GET '/usr/:cookie_id/new_password'
  # Steps:
  # 1. A User signs up and logs in
  # 2. Verify User password request details for response
  def test_new_password_by_cookie_id
    # Step 1
    @user = setup_user

    # Step 2
    get "/usr/#{@user.cookie_id}/new_password", {}
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    refute_nil(@parsed_response['new_password'], @parsed_response)
    refute_match(@user.password, @parsed_response['new_password'], @parsed_response)
  end

  ##
  # AS-5486 | Test Migrated Cheetah to Panda User Endpoints
  # - DELETE '/usr/:id'
  # Steps:
  # 1. A User signs up and logs in
  # 2. Verify deletion of User account (soft delete)
  # 3. Verify undelete of User account
  def test_delete_undelete_account_by_id
    # Step 1
    @user = setup_user

    # Step 2
    delete "/usr/#{@user.id}", {}
    assert_response(@response, :success)

    params = { 'email' => @user.email }

    get '/usr', params
    assert_response(@response, :success)
    assert_equal(@user.email, @parsed_response.first['email'], @parsed_response)
    assert_equal(true, @parsed_response.first['is_deleted'], @parsed_response)

    # Step 3
    post "/usr/#{@user.id}/undelete", {}
    assert_response(@response, :success)

    get '/usr', params
    assert_response(@response, :success)
    assert_equal(@user.email, @parsed_response.first['email'], @parsed_response)
    assert_equal(false, @parsed_response.first['is_deleted'], @parsed_response)
  end

  ##
  # AS-6469 | White list Names bypass Profanity Filter
  #
  # Steps:
  # 1. Verify successful response for 'hooker' on user create in Turtle
  # 2. Verify successful response for updates using 'hooker' on user in Panda
  def test_white_list_approved_profanity_in_names
    # Step 1
    opts = {
        'first_name' => 'hookr',
        'last_name' => 'Hooker'
    }

    @user = TurtleUser.new(opts)
    turtle_response = @user.register
    assert_response(turtle_response, :success)
    turtle_response = @user.login
    assert_response(turtle_response, :success)
    assert(@user.id, turtle_response.body)

    @user.login_oauth
    refute_nil(@user.oauth_token, 'oauth_token is missing!')

    get_user_info(@user.oauth_token)
    assert_equal(opts['first_name'], @parsed_response['first_name'], @parsed_response)
    assert_equal(opts['last_name'], @parsed_response['last_name'], @parsed_response)
    assert_equal('Hookr H.', @parsed_response['display_name'], @parsed_response)

    # Step 2
    params = {
        'user' => {
            'first_name' => 'Hooker',
            'user_name' => 'hooker'
        }
    }

    put "/usr/#{@user.cookie_id}", params
    assert_response(@response, :success)
    assert_equal(@user.cookie_id, @parsed_response['cookie_id'], @parsed_response)
    assert_equal(params['user']['first_name'], @parsed_response['first_name'], @parsed_response)
    assert_equal('Hooker H.', @parsed_response['display_name'], @parsed_response)
    assert_equal(params['user']['user_name'], @parsed_response['user_name'], @parsed_response)
  end

  ##
  # AS-6469 | White list Names bypass Profanity Filter
  # - Error Responses for Non White Listed Profanity
  #
  # Steps:
  # 1. Verify error response for profanity on user create in Turtle
  # 2. Verify error response for updates using profanity on user in Panda
  def test_non_white_list_profantiy_rejected_in_names
    # Step 1
    opts = {
        'first_name' => 'John',
        'last_name' => 'Shit'
    }

    @user = TurtleUser.new(opts)

    headers = { 'Accept' => 'application/json' }

    params = {
        'user' => {
            'first_name' => @user.first_name,
            'last_name' => @user.last_name,
            'email' => @user.email,
            'new_password' => @user.password,
            'new_password_confirmation' => @user.password,
            'vrid' => @user.vrid,
            'terms' => '1',
            'app_id' => 'WEB',
            'zip_code' => '91201'
        },
        'email_opt_in' => 'true',
        'location_opt_out' => 'false',
    }

    assign_http(Config['turtle']['host'])

    post '/usr', params, headers
    assert_response(@response, :client_error)
    assert_equal('ValidationError', @parsed_response['error'], @parsed_response)
    assert_equal('Please do not include profanity in your name.', @parsed_response['message'], @parsed_response)

    # Step 2
    @user = setup_user

    params = {
        'user' => {
            'first_name' => 'John',
            'user_name' => 'Shit'
        }
    }

    assign_http(Config['panda']['host'])

    put "/usr/#{@user.cookie_id}", params
    assert_response(@response, :client_error)
    assert_equal('Please do not include profanity in your name.', @parsed_response['user_name'].first, @parsed_response)
  end
end
